Parece que a rota foi adicionada corretamente no `host_b1`, mas o `ping` para `10.0.0.4` (um IP na `subnet_a`) não está funcionando. Isso pode acontecer por vários motivos. Vamos verificar e solucionar os possíveis problemas:

---

### 1. Verifique se o `firewall` está roteando corretamente
O contêiner `firewall` deve estar configurado para rotear o tráfego entre as sub-redes `10.0.0.0/24` (subnet_a) e `20.0.0.0/24` (subnet_b). Certifique-se de que:

- O `firewall` está habilitado para encaminhar pacotes entre as interfaces.
- As regras de `iptables` estão configuradas corretamente.

#### No `firewall`, verifique o encaminhamento de pacotes:
Acesse o shell do contêiner `firewall`:

```bash
docker exec -it firewall bash
```

Verifique se o encaminhamento de pacotes está habilitado:

```bash
sysctl net.ipv4.ip_forward
```

Se o resultado for `net.ipv4.ip_forward = 0`, habilite o encaminhamento:

```bash
sysctl -w net.ipv4.ip_forward=1
```

#### Verifique as regras de `iptables`:
Certifique-se de que as regras de `iptables` estão configuradas para permitir o tráfego entre as sub-redes. Execute:

```bash
iptables -L -v -n
```

Você deve ver regras que permitem o tráfego entre `eth0` (subnet_a) e `eth1` (subnet_b). Se não houver regras, adicione-as:

```bash
iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT
iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE
```

---

### 2. Verifique as rotas no `firewall`
O `firewall` também precisa saber como rotear o tráfego entre as sub-redes. Verifique as rotas no `firewall`:

```bash
ip route show
```

Você deve ver rotas para ambas as sub-redes:

```plaintext
10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.1
20.0.0.0/24 dev eth1 proto kernel scope link src 20.0.0.1
```

Se as rotas não estiverem presentes, adicione-as manualmente:

```bash
ip route add 10.0.0.0/24 dev eth0
ip route add 20.0.0.0/24 dev eth1
```

---

### 3. Verifique a conectividade entre `firewall` e `web_a`
Certifique-se de que o `firewall` pode alcançar o `web_a` na `subnet_a`. No `firewall`, execute:

```bash
ping 10.0.0.4
```

Se o `ping` não funcionar, verifique:

- O IP do `web_a` está correto?
- O `web_a` está em execução e respondendo?
- O `web_a` tem uma rota de volta para o `firewall`?

---

### 4. Verifique as rotas no `web_a`
O `web_a` também precisa saber como enviar pacotes de volta para o `host_b1`. Verifique as rotas no `web_a`:

```bash
docker exec -it web_a bash
ip route show
```

Você deve ver uma rota padrão para o gateway da `subnet_a` (por exemplo, `10.0.0.1`):

```plaintext
default via 10.0.0.1 dev eth0
```

Se a rota padrão não estiver configurada, adicione-a:

```bash
ip route add default via 10.0.0.1
```

---

### 5. Verifique as configurações de DNS
Se você estiver usando nomes de domínio em vez de IPs, certifique-se de que o DNS está configurado corretamente em todos os contêineres. No `host_b1`, verifique o arquivo `/etc/resolv.conf`:

```bash
cat /etc/resolv.conf
```

Ele deve apontar para o servidor DNS correto (por exemplo, `20.0.0.99`).

---

### 6. Resumo das verificações
1. **Firewall**:
   - Habilite o encaminhamento de pacotes (`net.ipv4.ip_forward=1`).
   - Configure as regras de `iptables` para permitir o tráfego entre as sub-redes.
   - Verifique as rotas no `firewall`.

2. **Roteamento**:
   - Adicione a rota `10.0.0.0/24 via 20.0.0.1` no `host_b1`.
   - Adicione a rota padrão no `web_a` (se necessário).

3. **Conectividade**:
   - Teste o `ping` do `firewall` para o `web_a`.
   - Teste o `ping` do `host_b1` para o `web_a`.

---

### 7. Teste final
Depois de realizar todas as verificações, teste novamente a comunicação:

```bash
docker exec -it host_b1 bash
ping 10.0.0.4
```

Se tudo estiver configurado corretamente, o `ping` deve funcionar.

---

### 8. Logs e Depuração
Se o problema persistir, verifique os logs do `firewall` e dos contêineres para identificar possíveis erros:

```bash
docker logs firewall
docker logs web_a
docker logs host_b1
```

Com essas etapas, você deve conseguir resolver o problema de conectividade entre `host_b1` e `web_a`.
